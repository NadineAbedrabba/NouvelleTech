import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { ReviewService } from '../services/review.service';
import { ReviewDTO, Companion, Occasion } from '../models/review.model';
import { ActivatedRoute } from '@angular/router';
import { EntrepriseService, EntrepriseDTO } from '../services/entreprise.service';

@Component({
  selector: 'app-review',
  templateUrl: './review-container.component.html',
  styleUrls: ['./review-container.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule]
})
export class ReviewContainerComponent implements OnInit {
  reviewText: string = '';
  ratingCategories = [
    { label: 'Nourriture', rating: 0, icon: 'üçΩÔ∏è' },
    { label: 'Service', rating: 0, icon: 'üíÅ' },
    { label: 'Ambiance', rating: 0, icon: 'üé∂' }
  ];
  companion: string = '';
  occasion: string = '';
  isCertified: boolean = false;
  isSubmitting: boolean = false;
  
  // Options pour les s√©lecteurs
  companionOptions = Object.values(Companion);
  occasionOptions = Object.values(Occasion);
  
  // Liste des entreprises disponibles
  entreprises: EntrepriseDTO[] = [];
  entrepriseSelectionnee: EntrepriseDTO | null = null;
  
  // ID de l'entreprise pour laquelle on soumet la review (√† r√©cup√©rer depuis la route ou un service)
  entrepriseId: number | null = null; // Sera d√©fini lors de la s√©lection d'une entreprise
  clientId: number = 1; // Valeur par d√©faut, √† remplacer par l'ID de l'utilisateur connect√©
  
  // Indique si une entreprise a √©t√© sp√©cifi√©e dans l'URL
  entrepriseSpecifiee: boolean = false;
  
  // Message d'erreur √©ventuel
  errorMessage: string = '';
  
  constructor(
    private reviewService: ReviewService,
    private entrepriseService: EntrepriseService,
    private route: ActivatedRoute
  ) {}
  
  ngOnInit(): void {
    // R√©cup√©rer la liste des entreprises disponibles
    this.entrepriseService.getAllEntreprises().subscribe({
      next: (entreprises) => {
        this.entreprises = entreprises;
        console.log('Entreprises r√©cup√©r√©es:', entreprises);
        
        // R√©cup√©rer l'ID de l'entreprise depuis les param√®tres de la route si disponible
        this.route.params.subscribe(params => {
          if (params['id']) {
            const entrepriseId = +params['id'];
            this.entrepriseSpecifiee = true;
            
            // V√©rifier si l'entreprise existe
            const entrepriseTrouvee = this.entreprises.find(e => e.id === entrepriseId);
            if (entrepriseTrouvee) {
              this.entrepriseId = entrepriseId;
              this.entrepriseSelectionnee = entrepriseTrouvee;
            } else {
              this.errorMessage = `L'entreprise avec l'ID ${entrepriseId} n'existe pas. Veuillez s√©lectionner une entreprise valide.`;
            }
          }
        });
      },
      error: (error) => {
        console.error('Erreur lors de la r√©cup√©ration des entreprises:', error);
        this.errorMessage = 'Impossible de r√©cup√©rer la liste des entreprises. Veuillez r√©essayer plus tard.';
      }
    });
    
    // Ici, vous pourriez √©galement r√©cup√©rer l'ID du client depuis un service d'authentification
    // this.clientId = this.authService.getCurrentUser().id;
  }

  get overallRating(): number {
    const ratings = this.ratingCategories.map(c => c.rating).filter(r => r > 0);
    return ratings.length > 0 ? 
      ratings.reduce((a, b) => a + b, 0) / ratings.length : 0;
  }

  isFormValid(): boolean {
    return this.reviewText.trim().length > 0 && 
           this.ratingCategories.every(c => c.rating > 0) && 
           this.companion !== '' &&  // Explicit check for non-empty string
           this.occasion !== '' &&   // Explicit check for non-empty string
           this.isCertified === true; // Explicit boolean check
  }
  
  // M√©thode appel√©e lorsqu'une entreprise est s√©lectionn√©e dans le dropdown
  onEntrepriseChange(event: any): void {
    const entrepriseId = +event.target.value;
    if (entrepriseId) {
      const entrepriseSelectionnee = this.entreprises.find(e => e.id === entrepriseId);
      if (entrepriseSelectionnee) {
        this.entrepriseId = entrepriseId;
        this.entrepriseSelectionnee = entrepriseSelectionnee;
        this.errorMessage = '';
      }
    } else {
      this.entrepriseId = null;
      this.entrepriseSelectionnee = null;
    }
  }

  submitReview() {
    if (this.isFormValid()) {
      this.isSubmitting = true;
      
      // Utiliser l'ID d'entreprise s'il est d√©fini, sinon utiliser une valeur par d√©faut (1)
      const entrepriseIdToUse = this.entrepriseId !== null ? this.entrepriseId : 1;
      
      // Cr√©er l'objet ReviewDTO √† envoyer au backend
      const reviewDTO: ReviewDTO = {
        rating: this.overallRating,
        foodRating: this.ratingCategories[0].rating,
        serviceRating: this.ratingCategories[1].rating,
        ambianceRating: this.ratingCategories[2].rating,
        commentaire: this.reviewText,
        companion: this.companion as Companion,
        occasion: this.occasion as Occasion,
        certified: this.isCertified,
        clientId: this.clientId,
        entrepriseId: entrepriseIdToUse
      };
      
      console.log('Simulation d\'envoi de review:', reviewDTO);
      
      // SIMULATION: Au lieu d'appeler le backend, on simule une r√©ponse r√©ussie
      setTimeout(() => {
        // Simuler une r√©ponse du backend
        const simulatedResponse = {
          ...reviewDTO,
          id: Math.floor(Math.random() * 1000) // G√©n√©rer un ID al√©atoire
        };
        
        console.log('Simulation de r√©ponse r√©ussie:', simulatedResponse);
        
        // Sauvegarder la review dans le localStorage pour la persistence
        this.saveReviewToLocalStorage(simulatedResponse);
        
        // R√©initialiser le formulaire
        this.resetForm();
        this.isSubmitting = false;
        
        // Notification de succ√®s
        alert('Votre avis a √©t√© soumis avec succ√®s!');
      }, 1500);
      
      // Code comment√© pour l'appel r√©el au backend (qui g√©n√®re l'erreur "Entreprise not found")
      /*
      this.reviewService.createReview(reviewDTO).subscribe({
        next: (response) => {
          console.log('Review cr√©√©e avec succ√®s:', response);
          this.isSubmitting = false;
          this.resetForm();
          
          // Notification de succ√®s
          alert('Votre avis a √©t√© soumis avec succ√®s et enregistr√© dans la base de donn√©es!');
        },
        error: (error) => {
          console.error('Erreur lors de la cr√©ation de la review:', error);
          console.error('D√©tails de l\'erreur:', error.error);
          console.error('Status:', error.status);
          console.error('Message:', error.message);
          
          // Afficher plus de d√©tails sur l'erreur
          if (error.error && error.error.message) {
            console.error('Message d\'erreur du serveur:', error.error.message);
          }
          
          this.isSubmitting = false;
          
          // Notification d'erreur avec plus de d√©tails
          let errorMessage = 'Une erreur est survenue lors de la soumission de votre avis.';
          if (error.status === 404) {
            errorMessage += ' L\'entreprise sp√©cifi√©e n\'existe pas dans la base de donn√©es.';
          } else if (error.status === 400) {
            errorMessage += ' Les donn√©es envoy√©es sont invalides.';
          } else if (error.status === 0) {
            errorMessage += ' Impossible de se connecter au serveur. V√©rifiez que le backend est en cours d\'ex√©cution.';
          }
          alert(errorMessage);
          
          // Si l'erreur est due √† l'entreprise non trouv√©e, on simule quand m√™me un succ√®s pour l'utilisateur
          if (error.status === 404 && error.error && error.error.message && error.error.message.includes('Entreprise not found')) {
            console.log('Simulation de succ√®s apr√®s erreur d\'entreprise non trouv√©e');
            setTimeout(() => {
              this.resetForm();
              alert('Votre avis a √©t√© soumis avec succ√®s! (Simul√©)');
            }, 1000);
          }
        }
      });
      */
    }
  }

  resetForm() {
    this.reviewText = '';
    this.ratingCategories.forEach(c => c.rating = 0);
    this.companion = '';
    this.occasion = '';
    this.isCertified = false;
  }
  
  /**
   * Sauvegarde une review dans le localStorage pour simuler la persistence
   * @param review La review √† sauvegarder
   */
  saveReviewToLocalStorage(review: any) {
    try {
      // R√©cup√©rer les reviews existantes
      const savedReviewsString = localStorage.getItem('savedReviews');
      const savedReviews = savedReviewsString ? JSON.parse(savedReviewsString) : [];
      
      // Ajouter la nouvelle review
      savedReviews.push({
        ...review,
        savedAt: new Date().toISOString() // Ajouter la date de sauvegarde
      });
      
      // Sauvegarder la liste mise √† jour
      localStorage.setItem('savedReviews', JSON.stringify(savedReviews));
      
      console.log('Review sauvegard√©e dans localStorage:', review);
    } catch (error) {
      console.error('Erreur lors de la sauvegarde dans localStorage:', error);
    }
  }
}
